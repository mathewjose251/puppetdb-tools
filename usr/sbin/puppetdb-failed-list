#!/usr/bin/python

#########################################################################
### Configuration #######################################################
#########################################################################

config_file = '/etc/puppetdb/puppetdb.json'
hours = 4

#########################################################################
### Declarations ########################################################
#########################################################################

from datetime import datetime, timedelta
import dateutil.parser, dateutil.tz
import json, optparse, re, requests, sys

## this isn't ideal, but until I actually start verifying the cert this
## is the best I can do
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

#########################################################################
### Subroutines #########################################################
#########################################################################

def parseConfig(file):
    """
    Load a json configuration from a configuration file.  Sets a global
    'config' variable.
    """
    global config

    try:
        config = json.load(open(config_file, 'r'))
    except IOError, e:
        print "file error:  %s" % e
        sys.exit (2)
    except Exception, e:
        print "unknown error:  %s" % e
        sys.exit (2)

    return config

def requestCert(url):
    """
    If the URL is https, then we will need to pass config['cert'] and
    config['key'].
    """
    if re.match('^https:', url):
        r = (config['cert'], config['key'])
    else:
        r = ()

    return r

def time_from_timestamp(timestamp):
    """
    Parse a timestamp with dateutil.parser.parse(), and set to the local
    timezone.  This is still usable for date math.
    """
    if timestamp is None:
        return False

    ts = dateutil.parser.parse(timestamp)
    local = ts.astimezone(dateutil.tz.tzlocal())
    return local

def timestamp_from_time(time):
    """
    """
    return time.strftime("%Y-%m-%dT%H:%M:%S%z")

def nodesActive (host_search, opt, p):
    """
    """

    query = "['~', ['fact', 'fqdn'], '^%s$']" % host_search
    try:
        payload = { 'query': json.dumps(eval(query))}
    except SyntaxError:
        p.error('Malformed query, check examples for help')

    items = {}

    headers = {'Accept': 'application/json'}
    try:
        nodes_url = "%s%s" % (opt.server, opt.nodes_url_base)
        if opt.debug:
            print "url: %s" % nodes_url
            print "payload: %s" % payload
        r = requests.get(nodes_url, headers=headers, params=payload,
            cert=requestCert(nodes_url), verify=False)
        for node in r.json():
            items[node['name']] = 1
    except:
        p.error ('bad json?: %s' % payload)

    return items

def nodesFailed (host_search, opt, p):
    """
    Return a list of hosts that failed.
    """

    try:
        host_query = ['~', 'certname', '^%s$' % host_search ]
        time_query = "['=', 'latest_report?', 'true']"
        query = "['and', %s, %s]" \
            % (host_query, time_query)

        payload = {
          'query':         json.dumps(eval(query)),
          'summarize-by':  'certname',
          'count-by':      'certname',
          'counts-filter': json.dumps(['>', 'failures', 0 ])
        }
    except SyntaxError:
        p.error('Malformed query, check examples for help')

    headers = {'Accept': 'application/json'}
    try:
        url = "%s%s" % ( opt.server, opt.event_counts_url_base )
        if opt.debug:
            print "url: %s" % url
            print "payload: %s" % payload
        r = requests.get(url, headers=headers, params=payload,
            cert=requestCert(url), verify=False)
        items = []
        for node in r.json():
            if 'subject' in node:
                items.append(node['subject']['title'])
        return items

    except Exception, e:
        p.error(e)
    except:
        p.error('bad json?: %s' % payload)



def hostFailedWhy(hostname):
    """
    Report on what on a host failed.  This consists of looking up
    all events that have occurred in the last $hours, and seeing if any
    events are repeated.  Repeated events are then reported on STDOUT,
    except for events of the type 'skipped'.
    """

    host_query = "['=', 'certname', '%s']" % hostname
    time_query = "['=', 'latest_report?', 'true']"
    query = "['and', %s, %s]" % (host_query, time_query)
    try:
        payload = { 'query': json.dumps(eval(query))}
    except SyntaxError:
        p.error('Malformed query, check examples for help')

    headers = {'Accept': 'application/json'}
    try:
        url = "%s%s" % ( opt.server, opt.events_url_base )
        if opt.debug:
            print "url: %s" % url
            print "payload: %s" % payload
        r = requests.get(url, headers=headers, params=payload,
            cert=requestCert(url), verify=False)
        items = {}
        text = []
        for event in r.json():
            string = changeString(event)
            if string is not None:
                text.append(string)

        return text

    except Exception, e:
        print 'bad json?: %s (%s)' % (payload, e)
        sys.exit(-1)

def changeString(event):
    """
    Creates and returns a single-line formatted string describing a single
    event, based on the output of the puppetdb 'events' endpoint.  This
    string is generally of the format:

        Service[ipmi]: stopped -> running (success)

    Events with the status 'skipped' are skipped if the skip flag is set.
    """

    new = event['new-value']
    old = event['old-value']
    title = event['resource-title']
    type  = event['resource-type']
    status = event['status']
    message = event['message']

    string = "%s[%s]: %s -> %s (%s)" % (type, title, old, new, message)

    if status != 'failure':
        return None

    return string


#########################################################################
### main () #############################################################
#########################################################################

def main():
    usage = "%prog [options] [HOSTPATTERN]"
    parseConfig(config_file)

    global p
    p = optparse.OptionParser (usage = usage,
        description = "query puppetdb for hosts that failed their last run")
    p.add_option ('--debug', dest='debug', action='store_true', default=False)
    p.add_option ('--server', dest='server', default=config['server'],
        help="puppetdb server (default: %default)")
    p.add_option ('--events_url_base', dest='events_url_base',
        default=config['events_url_base'],
        help="relative URL to puppetdb for default event query")
    p.add_option ('--event_counts_url_base', dest='event_counts_url_base',
        default=config['event_counts_url_base'],
        help="relative URL to puppetdb for event counts query")
    p.add_option ('--nodes_url_base', dest='nodes_url_base',
        default=config['nodes_url_base'],
        help="relative URL to puppetdb for node query")
    p.add_option ('--hours', dest='hours', default=hours, type='int',
        help='how many hours of reports?  default: %default')

    global opt
    opt, args = p.parse_args()

    if len(args) < 1: host_search = '.*'
    else:             host_search = args[0]

    active = nodesActive (host_search, opt, p)

    try:
        failed = nodesFailed (host_search, opt, p)
        for i in sorted(failed):
            if i in active:
                failures = hostFailedWhy(i)
                print "Node %s - %d failures" % (i, len(failures))
                for j in failures:
                    print "  %s" % j
                print ""

    except Exception, e:
        p.error(e)
    except:
        p.error('bad json?: %s' % payload)

    sys.exit(0)

if __name__ == '__main__':
    main()

#########################################################################
### POD Documentation ###################################################
#########################################################################
## We use this to generate man pages.

"""

=head1 NAME

puppetdb-failed-list - list events that failed, on a per-host basis

=head1 SYNOPSYS

B<puppetdb-failed-list>

B<puppetdb-failed-list> cmssrv.\*.fnal.gov

=head1 USAGE

puppetdb-failed-list queries the puppetdb to find hosts which had a
failure in their last run, and reports on each of those failures to
STDOUT.

The list of associated events is printed on STDOUT, in the format:

    Node d0cs3093.fnal.gov - 2 failures
      Augeas[add clogger.fnal.gov to log service]: None -> None (Saving failed, see debug)
      Augeas[add fefadmin03 as log host]: None -> None (Saving failed, see debug)

=head1 OPTIONS

=over 4

=item I<HOSTPATTERN>

Default host pattern to match.  Defaults to '.*'; remember that you may
need to escape wild cards if you're using this from the CLI.

=item --help

Prints some short help documentation and exits.

=back

=head1 AUTHOR

Tim Skirvin <tskirvin@fnal.gov>

Based in part on https://github.com/JHaals/puppetdb-grep

=head1 COPYRIGHT

Copyright 2014-2016, Fermi National Accelerator Laboratory

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=cut

"""
